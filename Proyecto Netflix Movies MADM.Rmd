---
title: "Proyecto Netflix Movies MADM"
author: "Laura Moreno, Josep Roman, Paul Ramírez"
date: "11/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### Tabla de Contenidos

1. Objetivo


2. Data Wrangle
    1. Importación de datos
    2. Limpieza de datos
    
    
3. Estadística Descriptiva
    1. Puntuaciones por fecha
    2. Puntuaciones por película
    3. Puntuaciones por usuario
    4. Número de puntuaciones por película, usuario y año lanzamiento
    5. Distribucion de los scores (boxplot,barplot)
    6. Series temporales de puntuaciones
    7. Distribución de cuantos usuarios evaluan cuantas pelis totales y diferentes
    
  
4. Sistema de Recomendación / Similaridad (opcional)


## 1. Objetivo


## 2. Data Wrangle

### 2.1 Importación de datos

**Info de los archivos "combined_data_.txt"**
The first line of each file contains the movie id followed by a colon. Each subsequent line in the file corresponds to a rating from a customer and its date in the following format:

  CustomerID,Rating,Date  
  
  * MovieIDs range from 1 to 17770 sequentially.
  * CustomerIDs range from 1 to 2649429, with gaps. There are 480189 users.
  * Ratings are on a five star (integral) scale from 1 to 5.
  * Dates have the format YYYY-MM-DD.  
  
```{r, include=FALSE}
library(tidyverse)
library(here) #permite ejecutar este rmd desde cualquier carpeta
library(timeDate)
library(magrittr) #permite hacer pipes en ambos sentidos


rm(aux, scores, titles, tt) #se eliminan las tablas por si las tenemos ya en el environment
```

**Carga archivo puntuaciones películas**
```{r}
aux = read_tsv(here("Raw data", "combined_data_1.txt"), col_names = FALSE, n_max = 30000) #lectura de las primeras


```

**Carga archivo titulos películas**
```{r}
rm(titles,tt)
titles = read_csv(here("Raw data",'movie_titles.csv'), col_names=F)
titles <- tibble(titles)
```




### 2.2 Limpieza de los datos

Limpieza datos puntuaciones películas

```{r}
aux %<>% mutate(fila=row_number()) #añadir columna con número de fila
filas = grep(":",aux$X1) #buscar filas con ":", filas comienzo nueva pelicula
filas_ID = aux %>% filter( fila %in% filas ) 
IDs = unique(filas_ID$X1)
reps = diff(c(filas_ID$fila,max(aux$fila)+1))
length(reps)
dim(aux)
sum(reps)
scores = aux %>% mutate(ID1=rep(filas_ID$X1,times=reps)) %>% filter(!(fila %in% filas) )

#ahora borramos los datos de la última película por si se han cortado a medias
scores %<>% filter( scores$fila < filas_ID$fila[length(filas_ID$fila)-1] )

# Ahora arregloamos la variable X1, y separamos la fecha en año, mes y día
scores %<>% separate(X1,into = c("CustomerID","Score","Date"), sep = ",")
scores %<>% mutate(Date_copy = Date)  %>% separate(Date_copy, into = c("Year", "Month", "Day"), sep = "-")

#Renombramos y reordenamos las variables
scores %<>% rename(MovieID = ID1)
scores <- select(scores, -fila) # eliminamos la columna fila
scores %<>% relocate(MovieID, CustomerID, Date, Year, Month, Day, Score)

#Quitamos los ":" de el campo MovieID
scores$MovieID <- scores$MovieID %>% str_replace(":", "")

# Cambiamos los tipos de variable necesarios

scores %<>% mutate(across(c(MovieID:CustomerID, Year:Score), as.integer))
scores %<>% mutate(Date = as.Date(Date))


summary(scores)
```
Vemos que tenemos información de la peliculas 1 a la 15, y las puntuaciones se hicieron entre el 2000 y el 2005 (mayoritariamente en 2005). Distribución de los meses y dias en que se puntuo es uniforme. 

Veamos más informacion sobre los datos:
```{r}
length(unique(scores$CustomerID)) #20537 usuarios distintos
table(scores$Score) # frecuencia puntuaciones
table(scores$MovieID) # frecuencia title
```
Limpieza datos títulos películas
```{r}
head(titles)
titles %<>% rename(MovieID = X1, Release_Year = X2, Title = X3)
titles  %<>% mutate(across(c(MovieID:Release_Year), as.integer))
```

**Left join de puntuaciones películas con los títulos

Hacemos un left join con 'titles' para añadir a la tabla 'scores' los títulos de cada película y el año en que se publicaron

- El `left_join` se queda con todas las observaciones que aparecen en el primer dataset, es decir, solo tendrá en cuenta las películas que observadas en el primer dataset.

- El `join` entre tablas lo hemos hecho con la columna `MovieID`, presente en ambas tablas. Tal y como vemos en la tabla `movies_titles.csv`, cada película tiene un `MovieID` único, lo que se conoce como _clave primaria_. No obstante, en la tabla `scores` cada MovieID puede ser puntuada por varios `CustomerID`, en este caso, la _clave primaria_ se constituye a partir de la combinación de ambas variables.

```{r}
scores %<>% left_join(titles, by = 'MovieID') 
summary(scores); head(scores)

```

## 3. Estadística Descriptiva

Valoración media por película, de mayor a menor:

```{r}
movie_score_avg <- scores %>%
  group_by(MovieID) %>%
  summarise(Mean_Score = mean(Score), n = n()) %>%
  left_join(titles, by = "MovieID") %>%
  arrange(desc(Mean_Score))

movie_score_avg
  
```

Valoración media por 'Release_Year', de mayor a menor:

```{r}
release_year_score_avg <- scores %>%
  group_by(Release_Year) %>%
  summarise(Mean_Score = mean(Score), n = n()) %>%
  arrange(desc(Mean_Score))

release_year_score_avg
```

Valoración media por día de la semana, de mayor a menor:

```{r}
scores_day_week <- scores %>% mutate(Day_Week = weekdays(Date))
scores_day_week %<>% mutate(Is_Weekend = isWeekend(Date))

day_week_score_avg <- scores_day_week %>%
  group_by(Day_Week) %>%
  summarise(Mean_Score = mean(Score), n = n()) %>%
  arrange(desc(Mean_Score))

day_week_score_avg
```

Valoración media entre semana / fin de semana:
  
```{r}
weekend_weekday_score_avg <- scores_day_week %>%
  group_by(Is_Weekend) %>%
  summarise(Mean_Score = mean(Score), n = n())

weekend_weekday_score_avg

n_scores_weekend = weekend_weekday_score_avg  %>% filter(Is_Weekend == TRUE) %>% select(n)
n_scores = sum(weekend_weekday_score_avg$n)
n_scores_weekend_weekday_ratio = n_scores_weekend / n_scores #el 18% de las valoraciones son en fin de semana, que es menos que el 28% de días que son fin de semana
```










